DefinedMethod(ObjectType(app/ExpressionPrinter$ExpressionStringifier),<init>,MethodDescriptor((app.ExpressionPrinter): void),app.ExpressionPrinter$ExpressionStringifier{ private void <init>(app.ExpressionPrinter) }) => ImpureByAnalysis
DefinedMethod(ObjectType(app/ExpressionPrinter$ExpressionStringifier),<init>,MethodDescriptor((app.ExpressionPrinter, app.ExpressionPrinter$1): void),app.ExpressionPrinter$ExpressionStringifier{ void <init>(app.ExpressionPrinter,app.ExpressionPrinter$1) }) => ImpureByAnalysis
DefinedMethod(ObjectType(app/ExpressionPrinter$ExpressionStringifier),recursiveAccept,MethodDescriptor((lib.Expression, java.util.function.BiFunction): java.lang.String),app.ExpressionPrinter$ExpressionStringifier{ public java.lang.String recursiveAccept(lib.Expression,java.util.function.BiFunction) }) => ImpureByAnalysis
DefinedMethod(ObjectType(app/ExpressionPrinter$ExpressionStringifier),visit,MethodDescriptor((lib.Expression): java.lang.Object),app.ExpressionPrinter$ExpressionStringifier{ public java.lang.Object visit(lib.Expression) }) => ImpureByAnalysis
DefinedMethod(ObjectType(app/ExpressionPrinter$ExpressionStringifier),visit,MethodDescriptor((lib.Expression): java.lang.String),app.ExpressionPrinter$ExpressionStringifier{ public java.lang.String visit(lib.Expression) }) => ImpureByAnalysis
DefinedMethod(ObjectType(app/ExpressionPrinter$OneConstant),$forward$lambda$getSuperToConstant$0,MethodDescriptor((): lib.Constant),app.ExpressionPrinter$OneConstant{ lib.Constant $forward$lambda$getSuperToConstant$0() }) => Pure
DefinedMethod(ObjectType(app/ExpressionPrinter$OneConstant),<init>,MethodDescriptor((): void),app.ExpressionPrinter$OneConstant{ private void <init>() }) => ImpureByAnalysis
DefinedMethod(ObjectType(app/ExpressionPrinter$OneConstant),<init>,MethodDescriptor((app.ExpressionPrinter$1): void),app.ExpressionPrinter$OneConstant{ void <init>(app.ExpressionPrinter$1) }) => ImpureByAnalysis
DefinedMethod(ObjectType(app/ExpressionPrinter$OneConstant),getSuperToConstant,MethodDescriptor((): java.util.function.Supplier),app.ExpressionPrinter$OneConstant{ public java.util.function.Supplier getSuperToConstant() }) => ImpureByAnalysis
DefinedMethod(ObjectType(app/ExpressionPrinter$OneConstant),lambda$getSuperToConstant$0,MethodDescriptor((): lib.Constant),app.ExpressionPrinter$OneConstant{ private lib.Constant lambda$getSuperToConstant$0() }) => ImpureByAnalysis
DefinedMethod(ObjectType(app/ExpressionPrinter$OneConstant),toConstant,MethodDescriptor((): lib.Constant),app.ExpressionPrinter$OneConstant{ public lib.Constant toConstant() }) => ImpureByAnalysis
DefinedMethod(ObjectType(app/ExpressionPrinter$ZeroConstant),<init>,MethodDescriptor((): void),app.ExpressionPrinter$ZeroConstant{ private void <init>() }) => ImpureByAnalysis
DefinedMethod(ObjectType(app/ExpressionPrinter$ZeroConstant),<init>,MethodDescriptor((app.ExpressionPrinter$1): void),app.ExpressionPrinter$ZeroConstant{ void <init>(app.ExpressionPrinter$1) }) => ImpureByAnalysis
DefinedMethod(ObjectType(app/ExpressionPrinter$ZeroConstant),toConstant,MethodDescriptor((): lib.Constant),app.ExpressionPrinter$ZeroConstant{ public lib.Constant toConstant() }) => ImpureByAnalysis
DefinedMethod(ObjectType(app/ExpressionPrinter),$forward$<init>,MethodDescriptor((): app.ExpressionPrinter),app.ExpressionPrinter{ static app.ExpressionPrinter $forward$<init>() }) => ImpureByAnalysis
DefinedMethod(ObjectType(app/ExpressionPrinter),$forward$incrementAll,MethodDescriptor((int[]): lib.Expression[]),app.ExpressionPrinter{ static lib.Expression[] $forward$incrementAll(int[]) }) => ImpureByAnalysis
DefinedMethod(ObjectType(app/ExpressionPrinter),<clinit>,MethodDescriptor((): void),app.ExpressionPrinter{ static void <clinit>() }) => ImpureByAnalysis
DefinedMethod(ObjectType(app/ExpressionPrinter),<init>,MethodDescriptor((): void),app.ExpressionPrinter{ private void <init>() }) => ImpureByAnalysis
DefinedMethod(ObjectType(app/ExpressionPrinter),incrementAll,MethodDescriptor((double[]): lib.Expression[]),app.ExpressionPrinter{ private static lib.Expression[] incrementAll(double[]) }) => ImpureByAnalysis
DefinedMethod(ObjectType(app/ExpressionPrinter),incrementAll,MethodDescriptor((int[]): lib.Expression[]),app.ExpressionPrinter{ private static lib.Expression[] incrementAll(int[]) }) => ImpureByAnalysis
DefinedMethod(ObjectType(app/ExpressionPrinter),instance,MethodDescriptor((): app.ExpressionPrinter),app.ExpressionPrinter{ static app.ExpressionPrinter instance() }) => ImpureByAnalysis
DefinedMethod(ObjectType(app/ExpressionPrinter),lambda$main$0,MethodDescriptor((int[]): int[]),app.ExpressionPrinter{ static int[] lambda$main$0(int[]) }) => ImpureByAnalysis
DefinedMethod(ObjectType(app/ExpressionPrinter),lambda$main$1,MethodDescriptor((lib.Expression[]): void),app.ExpressionPrinter{ static void lambda$main$1(lib.Expression[]) }) => ImpureByAnalysis
DefinedMethod(ObjectType(app/ExpressionPrinter),main,MethodDescriptor((java.lang.String[]): void),app.ExpressionPrinter{ public static void main(java.lang.String[]) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/Constant),<init>,MethodDescriptor((int): void),lib.Constant{ public void <init>(int) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/Constant),accept,MethodDescriptor((java.util.function.Function): java.lang.Object),lib.Constant{ public java.lang.Object accept(java.util.function.Function) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/Constant),eval,MethodDescriptor((lib.Map): lib.Constant),lib.Constant{ public lib.Constant eval(lib.Map) }) => SideEffectFree
DefinedMethod(ObjectType(lib/Constant),getValue,MethodDescriptor((): int),lib.Constant{ public int getValue() }) => CompileTimePure
DefinedMethod(ObjectType(lib/DecrementExpression$DecrementOperator),<init>,MethodDescriptor((): void),lib.DecrementExpression$DecrementOperator{ private void <init>() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/DecrementExpression$DecrementOperator),apply,MethodDescriptor((java.lang.Object): java.lang.Object),lib.DecrementExpression$DecrementOperator{ public java.lang.Object apply(java.lang.Object) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/DecrementExpression$DecrementOperator),apply,MethodDescriptor((lib.Constant): lib.Constant),lib.DecrementExpression$DecrementOperator{ public lib.Constant apply(lib.Constant) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/DecrementExpression$DecrementOperator),newInstance,MethodDescriptor((): lib.DecrementExpression$DecrementOperator),lib.DecrementExpression$DecrementOperator{ public static lib.DecrementExpression$DecrementOperator newInstance() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/DecrementExpression),<init>,MethodDescriptor((lib.Expression): void),lib.DecrementExpression{ public void <init>(lib.Expression) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/DecrementExpression),accept,MethodDescriptor((java.util.function.Function): java.lang.Object),lib.DecrementExpression{ public java.lang.Object accept(java.util.function.Function) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/DecrementExpression),eval,MethodDescriptor((lib.Map): lib.Constant),lib.UnaryExpression{ public lib.Constant eval(lib.Map) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/DecrementExpression),getExpr,MethodDescriptor((): lib.Expression),lib.UnaryExpression{ public lib.Expression getExpr() }) => SideEffectFree
DefinedMethod(ObjectType(lib/DecrementExpression),operator,MethodDescriptor((): lib.IUnaryOperator),lib.DecrementExpression{ public lib.IUnaryOperator operator() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/DecrementExpression),toString,MethodDescriptor((): java.lang.String),lib.DecrementExpression{ public java.lang.String toString() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/ExpressionVisitor),<init>,MethodDescriptor((): void),lib.ExpressionVisitor{ public void <init>() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/IUnaryOperator),identity,MethodDescriptor((): lib.IUnaryOperator),lib.IUnaryOperator{ public static lib.IUnaryOperator identity() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/IUnaryOperator),lambda$identity$0,MethodDescriptor((lib.Constant): lib.Constant),lib.IUnaryOperator{ public static lib.Constant lambda$identity$0(lib.Constant) }) => SideEffectFree
DefinedMethod(ObjectType(lib/IdentityExpression),<clinit>,MethodDescriptor((): void),lib.IdentityExpression{ static void <clinit>() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/IdentityExpression),<init>,MethodDescriptor((lib.Expression): void),lib.IdentityExpression{ public void <init>(lib.Expression) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/IdentityExpression),accept,MethodDescriptor((java.util.function.Function): java.lang.Object),lib.IdentityExpression{ public java.lang.Object accept(java.util.function.Function) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/IdentityExpression),eval,MethodDescriptor((lib.Map): lib.Constant),lib.UnaryExpression{ public lib.Constant eval(lib.Map) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/IdentityExpression),getExpr,MethodDescriptor((): lib.Expression),lib.UnaryExpression{ public lib.Expression getExpr() }) => SideEffectFree
DefinedMethod(ObjectType(lib/IdentityExpression),operator,MethodDescriptor((): lib.IUnaryOperator),lib.IdentityExpression{ public lib.IUnaryOperator operator() }) => SideEffectFree
DefinedMethod(ObjectType(lib/IdentityExpression),toString,MethodDescriptor((): java.lang.String),lib.IdentityExpression{ public java.lang.String toString() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/IncrementExpression),<init>,MethodDescriptor((lib.Expression): void),lib.IncrementExpression{ public void <init>(lib.Expression) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/IncrementExpression),accept,MethodDescriptor((java.util.function.Function): java.lang.Object),lib.IncrementExpression{ public java.lang.Object accept(java.util.function.Function) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/IncrementExpression),eval,MethodDescriptor((lib.Map): lib.Constant),lib.UnaryExpression{ public lib.Constant eval(lib.Map) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/IncrementExpression),getExpr,MethodDescriptor((): lib.Expression),lib.UnaryExpression{ public lib.Expression getExpr() }) => SideEffectFree
DefinedMethod(ObjectType(lib/IncrementExpression),lambda$operator$0,MethodDescriptor((lib.Constant): lib.Constant),lib.IncrementExpression{ static lib.Constant lambda$operator$0(lib.Constant) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/IncrementExpression),operator,MethodDescriptor((): lib.IUnaryOperator),lib.IncrementExpression{ public lib.IUnaryOperator operator() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/IncrementExpression),toString,MethodDescriptor((): java.lang.String),lib.IncrementExpression{ public java.lang.String toString() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/Map$1),<init>,MethodDescriptor((): void),lib.Map$1{ void <init>() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/Map$1),add,MethodDescriptor((java.lang.Object, java.lang.Object): void),lib.Map$1{ public void add(java.lang.Object,java.lang.Object) }) => DPure
DefinedMethod(ObjectType(lib/Map$1),get,MethodDescriptor((java.lang.Object): java.lang.Object),lib.Map$1{ public java.lang.Object get(java.lang.Object) }) => CompileTimePure
DefinedMethod(ObjectType(lib/Map$1),iterator,MethodDescriptor((): lib.Iterator),lib.Map{ public lib.Iterator iterator() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/Map$1),toString,MethodDescriptor((): java.lang.String),lib.Map{ public java.lang.String toString() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/Map$LinkedEntry),<init>,MethodDescriptor((lib.Map, java.lang.Object, java.lang.Object): void),lib.Map$LinkedEntry{ void <init>(lib.Map,java.lang.Object,java.lang.Object) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/Map$LinkedEntry),getNextEntry,MethodDescriptor((): lib.Map$LinkedEntry),lib.Map$LinkedEntry{ public lib.Map$LinkedEntry getNextEntry() }) => SideEffectFree
DefinedMethod(ObjectType(lib/Map$LinkedEntry),setNextEntry,MethodDescriptor((lib.Map$LinkedEntry): void),lib.Map$LinkedEntry{ public void setNextEntry(lib.Map$LinkedEntry) }) => ExternallyPure
DefinedMethod(ObjectType(lib/Map$LinkedEntry),toString,MethodDescriptor((): java.lang.String),lib.Map$LinkedEntry{ public java.lang.String toString() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/Map$MapIterator),<init>,MethodDescriptor((lib.Map, lib.Map$LinkedEntry): void),lib.Map$MapIterator{ public void <init>(lib.Map,lib.Map$LinkedEntry) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/Map$MapIterator),hasNext,MethodDescriptor((): boolean),lib.Map$MapIterator{ public boolean hasNext() }) => SideEffectFree
DefinedMethod(ObjectType(lib/Map$MapIterator),next,MethodDescriptor((): java.lang.Object),lib.Map$MapIterator{ public java.lang.Object next() }) => DExternallySideEffectFree
DefinedMethod(ObjectType(lib/Map$MapIterator),next,MethodDescriptor((): lib.Map$LinkedEntry),lib.Map$MapIterator{ public lib.Map$LinkedEntry next() }) => DExternallySideEffectFree
DefinedMethod(ObjectType(lib/Map$MapIterator),remove,MethodDescriptor((): void),lib.Map$MapIterator{ public void remove() }) => DPure
DefinedMethod(ObjectType(lib/Map),<clinit>,MethodDescriptor((): void),lib.Map{ static void <clinit>() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/Map),<init>,MethodDescriptor((): void),lib.Map{ public void <init>() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/Map),add,MethodDescriptor((java.lang.Object, java.lang.Object): void),lib.Map{ public void add(java.lang.Object,java.lang.Object) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/Map),contentAsString,MethodDescriptor((lib.Map$LinkedEntry): java.lang.String),lib.Map{ private java.lang.String contentAsString(lib.Map$LinkedEntry) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/Map),get,MethodDescriptor((java.lang.Object): java.lang.Object),lib.Map{ public java.lang.Object get(java.lang.Object) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/Map),iterator,MethodDescriptor((): lib.Iterator),lib.Map{ public lib.Iterator iterator() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/Map),toString,MethodDescriptor((): java.lang.String),lib.Map{ public java.lang.String toString() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/SquareExpression),<init>,MethodDescriptor((lib.Expression): void),lib.SquareExpression{ public void <init>(lib.Expression) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/SquareExpression),accept,MethodDescriptor((java.util.function.Function): java.lang.Object),lib.SquareExpression{ public java.lang.Object accept(java.util.function.Function) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/SquareExpression),eval,MethodDescriptor((lib.Map): lib.Constant),lib.SquareExpression{ public lib.Constant eval(lib.Map) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/SquareExpression),getExpr,MethodDescriptor((): lib.Expression),lib.UnaryExpression{ public lib.Expression getExpr() }) => SideEffectFree
DefinedMethod(ObjectType(lib/SquareExpression),lambda$operator$0,MethodDescriptor((lib.Constant): lib.Constant),lib.SquareExpression{ static lib.Constant lambda$operator$0(lib.Constant) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/SquareExpression),operator,MethodDescriptor((): lib.IUnaryOperator),lib.SquareExpression{ public lib.IUnaryOperator operator() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/SquareExpression),toString,MethodDescriptor((): java.lang.String),lib.SquareExpression{ public java.lang.String toString() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/Stack$StackIterator),<init>,MethodDescriptor((lib.Stack, java.lang.Object[], int): void),lib.Stack$StackIterator{ public void <init>(lib.Stack,java.lang.Object[],int) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/Stack$StackIterator),hasNext,MethodDescriptor((): boolean),lib.Stack$StackIterator{ public boolean hasNext() }) => SideEffectFree
DefinedMethod(ObjectType(lib/Stack$StackIterator),next,MethodDescriptor((): java.lang.Object),lib.Stack$StackIterator{ public java.lang.Object next() }) => DExternallySideEffectFree
DefinedMethod(ObjectType(lib/Stack$StackIterator),remove,MethodDescriptor((): void),lib.Stack$StackIterator{ public void remove() }) => DPure
DefinedMethod(ObjectType(lib/Stack),<init>,MethodDescriptor((): void),lib.Stack{ public void <init>() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/Stack),isEmpty,MethodDescriptor((): boolean),lib.Stack{ public boolean isEmpty() }) => SideEffectFree
DefinedMethod(ObjectType(lib/Stack),iterator,MethodDescriptor((): lib.Iterator),lib.Stack{ public lib.Iterator iterator() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/Stack),peek,MethodDescriptor((): java.lang.Object),lib.Stack{ public java.lang.Object peek() }) => DSideEffectFree
DefinedMethod(ObjectType(lib/Stack),pop,MethodDescriptor((): java.lang.Object),lib.Stack{ public java.lang.Object pop() }) => DExternallySideEffectFree
DefinedMethod(ObjectType(lib/Stack),push,MethodDescriptor((java.lang.Object): void),lib.Stack{ public void push(java.lang.Object) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/Stack),size,MethodDescriptor((): int),lib.Stack{ public int size() }) => SideEffectFree
DefinedMethod(ObjectType(lib/UnaryExpression$1),<clinit>,MethodDescriptor((): void),lib.UnaryExpression$1{ static void <clinit>() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/UnaryExpression),<init>,MethodDescriptor((lib.Expression): void),lib.UnaryExpression{ public void <init>(lib.Expression) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/UnaryExpression),createUnaryExpressions,MethodDescriptor((lib.UnaryOperator, lib.Expression): lib.UnaryExpression),lib.UnaryExpression{ public static lib.UnaryExpression createUnaryExpressions(lib.UnaryOperator,lib.Expression) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/UnaryExpression),eval,MethodDescriptor((lib.Map): lib.Constant),lib.UnaryExpression{ public lib.Constant eval(lib.Map) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/UnaryExpression),getExpr,MethodDescriptor((): lib.Expression),lib.UnaryExpression{ public lib.Expression getExpr() }) => SideEffectFree
DefinedMethod(ObjectType(lib/UnaryOperator),<clinit>,MethodDescriptor((): void),lib.UnaryOperator{ static void <clinit>() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/UnaryOperator),<init>,MethodDescriptor((java.lang.String, int, java.lang.String): void),lib.UnaryOperator{ private void <init>(java.lang.String,int,java.lang.String) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/UnaryOperator),consoleWrite,MethodDescriptor((java.lang.String): void),lib.UnaryOperator{ private void consoleWrite(java.lang.String) }) => DPure
DefinedMethod(ObjectType(lib/UnaryOperator),toString,MethodDescriptor((): java.lang.String),lib.UnaryOperator{ public java.lang.String toString() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/UnaryOperator),valueOf,MethodDescriptor((java.lang.String): lib.UnaryOperator),lib.UnaryOperator{ public static lib.UnaryOperator valueOf(java.lang.String) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/UnaryOperator),values,MethodDescriptor((): lib.UnaryOperator[]),lib.UnaryOperator{ public static lib.UnaryOperator[] values() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/callgraph/AnalysisMode),<clinit>,MethodDescriptor((): void),lib.annotations.callgraph.AnalysisMode{ static void <clinit>() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/callgraph/AnalysisMode),<init>,MethodDescriptor((java.lang.String, int): void),lib.annotations.callgraph.AnalysisMode{ private void <init>(java.lang.String,int) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/callgraph/AnalysisMode),valueOf,MethodDescriptor((java.lang.String): lib.annotations.callgraph.AnalysisMode),lib.annotations.callgraph.AnalysisMode{ public static lib.annotations.callgraph.AnalysisMode valueOf(java.lang.String) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/callgraph/AnalysisMode),values,MethodDescriptor((): lib.annotations.callgraph.AnalysisMode[]),lib.annotations.callgraph.AnalysisMode{ public static lib.annotations.callgraph.AnalysisMode[] values() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/callgraph/CallGraphAlgorithm),<clinit>,MethodDescriptor((): void),lib.annotations.callgraph.CallGraphAlgorithm{ static void <clinit>() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/callgraph/CallGraphAlgorithm),<init>,MethodDescriptor((java.lang.String, int, lib.annotations.callgraph.CallGraphAlgorithm[]): void),lib.annotations.callgraph.CallGraphAlgorithm{ private void <init>(java.lang.String,int,lib.annotations.callgraph.CallGraphAlgorithm[]) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/callgraph/CallGraphAlgorithm),compare,MethodDescriptor((lib.annotations.callgraph.CallGraphAlgorithm): lib.annotations.callgraph.CallGraphAlgorithmOrder),lib.annotations.callgraph.CallGraphAlgorithm{ public lib.annotations.callgraph.CallGraphAlgorithmOrder compare(lib.annotations.callgraph.CallGraphAlgorithm) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/callgraph/CallGraphAlgorithm),getDirectlyLessPreciseCallGraphAlgorithms,MethodDescriptor((): lib.annotations.callgraph.CallGraphAlgorithm[]),lib.annotations.callgraph.CallGraphAlgorithm{ public lib.annotations.callgraph.CallGraphAlgorithm[] getDirectlyLessPreciseCallGraphAlgorithms() }) => SideEffectFree
DefinedMethod(ObjectType(lib/annotations/callgraph/CallGraphAlgorithm),getInfimum,MethodDescriptor((lib.annotations.callgraph.CallGraphAlgorithm): lib.annotations.callgraph.CallGraphAlgorithm),lib.annotations.callgraph.CallGraphAlgorithm{ public lib.annotations.callgraph.CallGraphAlgorithm getInfimum(lib.annotations.callgraph.CallGraphAlgorithm) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/callgraph/CallGraphAlgorithm),getSupremum,MethodDescriptor((lib.annotations.callgraph.CallGraphAlgorithm): lib.annotations.callgraph.CallGraphAlgorithm),lib.annotations.callgraph.CallGraphAlgorithm{ public lib.annotations.callgraph.CallGraphAlgorithm getSupremum(lib.annotations.callgraph.CallGraphAlgorithm) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/callgraph/CallGraphAlgorithm),hasGreaterOrEqualPrecision,MethodDescriptor((lib.annotations.callgraph.CallGraphAlgorithm): boolean),lib.annotations.callgraph.CallGraphAlgorithm{ public boolean hasGreaterOrEqualPrecision(lib.annotations.callgraph.CallGraphAlgorithm) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/callgraph/CallGraphAlgorithm),hasGreaterPrecision,MethodDescriptor((lib.annotations.callgraph.CallGraphAlgorithm): boolean),lib.annotations.callgraph.CallGraphAlgorithm{ public boolean hasGreaterPrecision(lib.annotations.callgraph.CallGraphAlgorithm) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/callgraph/CallGraphAlgorithm),hasSmallerOrEqualPrecision,MethodDescriptor((lib.annotations.callgraph.CallGraphAlgorithm): boolean),lib.annotations.callgraph.CallGraphAlgorithm{ public boolean hasSmallerOrEqualPrecision(lib.annotations.callgraph.CallGraphAlgorithm) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/callgraph/CallGraphAlgorithm),hasSmallerPrecision,MethodDescriptor((lib.annotations.callgraph.CallGraphAlgorithm): boolean),lib.annotations.callgraph.CallGraphAlgorithm{ public boolean hasSmallerPrecision(lib.annotations.callgraph.CallGraphAlgorithm) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/callgraph/CallGraphAlgorithm),valueOf,MethodDescriptor((java.lang.String): lib.annotations.callgraph.CallGraphAlgorithm),lib.annotations.callgraph.CallGraphAlgorithm{ public static lib.annotations.callgraph.CallGraphAlgorithm valueOf(java.lang.String) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/callgraph/CallGraphAlgorithm),values,MethodDescriptor((): lib.annotations.callgraph.CallGraphAlgorithm[]),lib.annotations.callgraph.CallGraphAlgorithm{ public static lib.annotations.callgraph.CallGraphAlgorithm[] values() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/callgraph/CallGraphAlgorithmOrder),<clinit>,MethodDescriptor((): void),lib.annotations.callgraph.CallGraphAlgorithmOrder{ static void <clinit>() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/callgraph/CallGraphAlgorithmOrder),<init>,MethodDescriptor((java.lang.String, int): void),lib.annotations.callgraph.CallGraphAlgorithmOrder{ private void <init>(java.lang.String,int) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/callgraph/CallGraphAlgorithmOrder),valueOf,MethodDescriptor((java.lang.String): lib.annotations.callgraph.CallGraphAlgorithmOrder),lib.annotations.callgraph.CallGraphAlgorithmOrder{ public static lib.annotations.callgraph.CallGraphAlgorithmOrder valueOf(java.lang.String) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/callgraph/CallGraphAlgorithmOrder),values,MethodDescriptor((): lib.annotations.callgraph.CallGraphAlgorithmOrder[]),lib.annotations.callgraph.CallGraphAlgorithmOrder{ public static lib.annotations.callgraph.CallGraphAlgorithmOrder[] values() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/callgraph/TargetResolution),<clinit>,MethodDescriptor((): void),lib.annotations.callgraph.TargetResolution{ static void <clinit>() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/callgraph/TargetResolution),<init>,MethodDescriptor((java.lang.String, int): void),lib.annotations.callgraph.TargetResolution{ private void <init>(java.lang.String,int) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/callgraph/TargetResolution),valueOf,MethodDescriptor((java.lang.String): lib.annotations.callgraph.TargetResolution),lib.annotations.callgraph.TargetResolution{ public static lib.annotations.callgraph.TargetResolution valueOf(java.lang.String) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/callgraph/TargetResolution),values,MethodDescriptor((): lib.annotations.callgraph.TargetResolution[]),lib.annotations.callgraph.TargetResolution{ public static lib.annotations.callgraph.TargetResolution[] values() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/documentation/CGCategory),<clinit>,MethodDescriptor((): void),lib.annotations.documentation.CGCategory{ static void <clinit>() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/documentation/CGCategory),<init>,MethodDescriptor((java.lang.String, int): void),lib.annotations.documentation.CGCategory{ private void <init>(java.lang.String,int) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/documentation/CGCategory),valueOf,MethodDescriptor((java.lang.String): lib.annotations.documentation.CGCategory),lib.annotations.documentation.CGCategory{ public static lib.annotations.documentation.CGCategory valueOf(java.lang.String) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/documentation/CGCategory),values,MethodDescriptor((): lib.annotations.documentation.CGCategory[]),lib.annotations.documentation.CGCategory{ public static lib.annotations.documentation.CGCategory[] values() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/properties/CallabilityKeys),<clinit>,MethodDescriptor((): void),lib.annotations.properties.CallabilityKeys{ static void <clinit>() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/properties/CallabilityKeys),<init>,MethodDescriptor((java.lang.String, int): void),lib.annotations.properties.CallabilityKeys{ private void <init>(java.lang.String,int) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/properties/CallabilityKeys),valueOf,MethodDescriptor((java.lang.String): lib.annotations.properties.CallabilityKeys),lib.annotations.properties.CallabilityKeys{ public static lib.annotations.properties.CallabilityKeys valueOf(java.lang.String) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/properties/CallabilityKeys),values,MethodDescriptor((): lib.annotations.properties.CallabilityKeys[]),lib.annotations.properties.CallabilityKeys{ public static lib.annotations.properties.CallabilityKeys[] values() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/properties/EntryPointKeys),<clinit>,MethodDescriptor((): void),lib.annotations.properties.EntryPointKeys{ static void <clinit>() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/properties/EntryPointKeys),<init>,MethodDescriptor((java.lang.String, int): void),lib.annotations.properties.EntryPointKeys{ private void <init>(java.lang.String,int) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/properties/EntryPointKeys),valueOf,MethodDescriptor((java.lang.String): lib.annotations.properties.EntryPointKeys),lib.annotations.properties.EntryPointKeys{ public static lib.annotations.properties.EntryPointKeys valueOf(java.lang.String) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/properties/EntryPointKeys),values,MethodDescriptor((): lib.annotations.properties.EntryPointKeys[]),lib.annotations.properties.EntryPointKeys{ public static lib.annotations.properties.EntryPointKeys[] values() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/properties/FactoryMethodKeys),<clinit>,MethodDescriptor((): void),lib.annotations.properties.FactoryMethodKeys{ static void <clinit>() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/properties/FactoryMethodKeys),<init>,MethodDescriptor((java.lang.String, int): void),lib.annotations.properties.FactoryMethodKeys{ private void <init>(java.lang.String,int) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/properties/FactoryMethodKeys),valueOf,MethodDescriptor((java.lang.String): lib.annotations.properties.FactoryMethodKeys),lib.annotations.properties.FactoryMethodKeys{ public static lib.annotations.properties.FactoryMethodKeys valueOf(java.lang.String) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/properties/FactoryMethodKeys),values,MethodDescriptor((): lib.annotations.properties.FactoryMethodKeys[]),lib.annotations.properties.FactoryMethodKeys{ public static lib.annotations.properties.FactoryMethodKeys[] values() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/properties/InstantiabilityKeys),<clinit>,MethodDescriptor((): void),lib.annotations.properties.InstantiabilityKeys{ static void <clinit>() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/properties/InstantiabilityKeys),<init>,MethodDescriptor((java.lang.String, int): void),lib.annotations.properties.InstantiabilityKeys{ private void <init>(java.lang.String,int) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/properties/InstantiabilityKeys),valueOf,MethodDescriptor((java.lang.String): lib.annotations.properties.InstantiabilityKeys),lib.annotations.properties.InstantiabilityKeys{ public static lib.annotations.properties.InstantiabilityKeys valueOf(java.lang.String) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/properties/InstantiabilityKeys),values,MethodDescriptor((): lib.annotations.properties.InstantiabilityKeys[]),lib.annotations.properties.InstantiabilityKeys{ public static lib.annotations.properties.InstantiabilityKeys[] values() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/properties/ProjectAccessibilityKeys),<clinit>,MethodDescriptor((): void),lib.annotations.properties.ProjectAccessibilityKeys{ static void <clinit>() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/properties/ProjectAccessibilityKeys),<init>,MethodDescriptor((java.lang.String, int): void),lib.annotations.properties.ProjectAccessibilityKeys{ private void <init>(java.lang.String,int) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/properties/ProjectAccessibilityKeys),valueOf,MethodDescriptor((java.lang.String): lib.annotations.properties.ProjectAccessibilityKeys),lib.annotations.properties.ProjectAccessibilityKeys{ public static lib.annotations.properties.ProjectAccessibilityKeys valueOf(java.lang.String) }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/annotations/properties/ProjectAccessibilityKeys),values,MethodDescriptor((): lib.annotations.properties.ProjectAccessibilityKeys[]),lib.annotations.properties.ProjectAccessibilityKeys{ public static lib.annotations.properties.ProjectAccessibilityKeys[] values() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/testutils/CallbackTest),<init>,MethodDescriptor((): void),lib.testutils.CallbackTest{ public void <init>() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/testutils/CallbackTest),callback,MethodDescriptor((): void),lib.testutils.CallbackTest{ public static void callback() }) => CompileTimePure
DefinedMethod(ObjectType(lib/testutils/CallbackTest),garbageCollectorCall,MethodDescriptor((): void),lib.testutils.CallbackTest{ public static void garbageCollectorCall() }) => CompileTimePure
DefinedMethod(ObjectType(lib/testutils/CallbackTest),runnableRunCall,MethodDescriptor((): void),lib.testutils.CallbackTest{ public static void runnableRunCall() }) => CompileTimePure
DefinedMethod(ObjectType(lib/testutils/StaticInitializerTest),<init>,MethodDescriptor((): void),lib.testutils.StaticInitializerTest{ public void <init>() }) => ImpureByAnalysis
DefinedMethod(ObjectType(lib/testutils/StaticInitializerTest),staticCall,MethodDescriptor((): void),lib.testutils.StaticInitializerTest{ public static void staticCall() }) => CompileTimePure
