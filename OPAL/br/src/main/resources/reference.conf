org.opalj {

  br {
    # The CFG's structure is validated; primarily of interest when the algorithms related to
    # computing the CFG are maintained, extended, or changed.
    cfg.CFG.Validate = false,

    reader {
      ClassFileReader {
        BytecodeOptimizer {
          simplifyControlFlow = true, // default is "true"
          logControlFlowSimplification = false // default is "false"
        },
        Invokedynamic {
          rewrite = true, // default is "true"
          logLambdaRewrites = false, // default is "false"
          logStringConcatRewrites = false, // default is "false"
          logUnknownInvokeDynamics = true // default is "false"
        },
        deleteSynthesizedClassFilesAttributes = true // default is "true"
      }
    }

    analyses {
      cg {
        ClosedPackagesKey {
          analysis = "org.opalj.br.analyses.cg.ClosedCodeBase" # considers all packages closed (e.g. suitable when analyzing an application)

          #analysis = "org.opalj.br.analyses.cg.OpenCodeBase" # considers all packages open (e.g. suitable for security analyses)

          #analysis = "org.opalj.br.analyses.cg.ClosedPackagesConfiguration"
          #closedPackages = "java(/.*)*"
          # Use a regular expresion (e.g. "java(/.*)*") to specify all packages
          # that shall be considered closed. In some cases, it might be easier to 
          # specify all open packages. In this case it's possible to invert the
          # specified regular expression (e.g. "^(java(/.*)*)"). The latter example
          # would consider all packages except the java packages as closed.

        }

        ClassExtensibilityKey {
          analysis = "org.opalj.br.analyses.cg.ConfiguredFinalClasses"
          finalClasses = [] # used by org.opalj.br.analyses.cg.ConfiguredFinalClasses
        }

        InitialEntryPointsKey {
          #analysis = "org.opalj.br.analyses.cg.ApplicationEntryPointsFinder"
          analysis = "org.opalj.br.analyses.cg.LibraryEntryPointsFinder"
          #analysis = "org.opalj.br.analyses.cg.MetaEntryPointsFinder"
          entryPoints = [

          ]
          # additional entry points can be specified by adding a respective tuple that must consist of
          # a class name and a method name and can be refined by also defining a method descriptor.
          # In addition, the specified class name can be suffixed with a "+" which implies that all methods that match the
          # specified name -- and if definied descriptor -- from subtypes are considered too.
          # eg.:
          # entryPoints = [
          #   {declaringClass = "java/util/List+", name = "add"},
          #   {declaringClass = "java/util/List", name = "remove", descriptor = "(I)Z"}
          # ]
          # Please note that the first entry point, by adding the "=" to the declaring class' name, considers all
          # "add" methods from all subtypes independently form the respective method's descriptor. In constrast,
          # the second entry does specify a descriptor and does not consider list subtypes (by not suffixing a plus to
          # the declaringClass) which implies that only the remove method with this descriptor is considered as entry point.
        }

        InitialInstantiatedTypesKey {
          #analysis = "org.opalj.br.analyses.cg.ApplicationInstantiatedTypesFinder"
          analysis = "org.opalj.br.analyses.cg.LibraryInstantiatedTypesFinder"

          instantiatedTypes = [

          ]
        }
      }
    }
  }

  fpcf {

    # Prints out information about the executed analyses.
    analyses.FPCFAnalysesManager {
      Trace = true
    }

    registry {
      analyses {
        "L0FieldMutabilityAnalysis" {
          description = "Determines if fields are (effectively) final.",
          eagerFactory = "org.opalj.fpcf.analyses.EagerL0FieldMutabilityAnalysis",
          lazyFactory = "org.opalj.fpcf.analyses.LazyL0FieldMutabilityAnalysis"
        },
        "L0CompileTimeConstancyAnalysis" {
          description = "Determines if static fields are compile time constants.",
          eagerFactory = "org.opalj.fpcf.analyses.EagerL0CompileTimeConstancyAnalysis",
          lazyFactory = "org.opalj.fpcf.analyses.LazyL0CompileTimeConstancyAnalysis"
        },
        "L0SelfReferenceLeakageAnalysis" {
          description = "Determines if an object may leak its self reference (`this`).",
          eagerFactory = "org.opalj.fpcf.analyses.L0SelfReferenceLeakageAnalysis"
          #TODO This one does not yet have a lazy factory
        },
        "ClassImmutabilityAnalysis" {
          description = "Determines if instances of a class are immutable.",
          eagerFactory = "org.opalj.fpcf.analyses.EagerClassImmutabilityAnalysis",
          lazyFactory = "org.opalj.fpcf.analyses.LazyClassImmutabilityAnalysis"
        },
        "L1ThrownExceptionsAnalysis" {
          description = "Determines the exceptions that are thrown by a method.",
          eagerFactory = "org.opalj.fpcf.analyses.EagerL1ThrownExceptionsAnalysis",
          lazyFactory = "org.opalj.fpcf.analyses.LazyL1ThrownExceptionsAnalysis"
        },
        "L0AllocationFreenessAanalysis" {
          description = "Determines if a method may (transitively) cause allocations.",
          eagerFactory = "org.opalj.fpcf.analyses.EagerL0AllocationFreenessAnalysis",
          lazyFactory = "org.opalj.fpcf.analyses.LazyL0AllocationFreenessAnalysis"
        },
        "StaticDataUsageAnalysis" {
          description = "Determines if a method uses only compile time constant static state.",
          eagerFactory = "org.opalj.fpcf.analyses.EagerStaticDataUsageAnalysis",
          lazyFactory = "org.opalj.fpcf.analyses.LazyStaticDataUsageAnalysis"
        },
        "L0PurityAnalysis" {
          description = "Determines a method's purity.",
          eagerFactory = "org.opalj.fpcf.analyses.EagerL0PurityAnalysis",
          lazyFactory = "org.opalj.fpcf.analyses.LazyL0PurityAnalysis"
        },
        // The virtual/aggregating ones...
        "TypeImmutabilityAnalysis" {
          description = "Determines if instances of a type (including subclasses) are immutable.",
          eagerFactory = "org.opalj.fpcf.analyses.EagerTypeImmutabilityAnalysis",
          lazyFactory = "org.opalj.fpcf.analyses.LazyTypeImmutabilityAnalysis"
        },
        "VirtualMethodThrownExceptionsAnalysis" {
          description = "Determines the aggregated thrown exceptions for a virtual method.",
          eagerFactory = "org.opalj.fpcf.analyses.EagerVirtualMethodThrownExceptionsAnalysis",
          lazyFactory = "org.opalj.fpcf.analyses.LazyVirtualMethodThrownExceptionsAnalysis"
        },
        "VirtualMethodAllocationFreenessAnalysis" {
          description = "Determines the aggregated allocation freeness for a virtual method.",
          eagerFactory = "org.opalj.fpcf.analyses.EagerVirtualMethodPurityAnalysis",
          lazyFactory = "org.opalj.fpcf.analyses.LazyVirtualMethodPurityAnalysis"
        },
        "VirtualMethodStaticDataUsageAnalysis" {
          description = "Determines the aggregated static data use freeness for a virtual method.",
          eagerFactory = "org.opalj.fpcf.analyses.EagerVirtualMethodStaticDataUsageAnalysis",
          lazyFactory = "org.opalj.fpcf.analyses.LazyVirtualMethodStaticDataUsageAnalysis"
        },
        "VirtualMethodPurityAnalysis" {
          description = "Determines the aggregated purity for a virtual method.",
          eagerFactory = "org.opalj.fpcf.analyses.EagerVirtualMethodPurityAnalysis",
          lazyFactory = "org.opalj.fpcf.analyses.LazyVirtualMethodPurityAnalysis"
        },
        "VirtualCallAggregatingEscapeAnalysis" {
          description = "Determines the aggregated escape level for a virtual formal parameter.",
          eagerFactory = "org.opalj.fpcf.analyses.EagerVirtualCallAggregatingEscapeAnalysis",
          lazyFactory = "org.opalj.fpcf.analyses.LazyVirtualCallAggregatingEscapeAnalysis"
        },
        "VirtualReturnValueFreshnessAnalysis" {
          description = "Determines the aggregated return value freshness for a virtual method.",
          eagerFactory = "org.opalj.fpcf.analyses.EagerVirtualReturnValueFreshnessAnalysis",
          lazyFactory = "org.opalj.fpcf.analyses.LazyVirtualReturnValueFreshnessAnalysis"
        }
      }
    }

    analysis {
      L0SelfReferenceLeakage {
        debug = true // default is "false"
      },
      RTACallGraphAnalysis {
        nativeMethods = [
          {
            cf = "java/lang/Class", m = "forName0", desc = "(Ljava/lang/String;ZLjava/lang/ClassLoader;Ljava/lang/Class;)Ljava/lang/Class;"
            instantiatedTypes = ["java/lang/Class"]
          },
          {
            cf = "java/lang/Class", m = "getConstantPool", desc = "()Ljava/reflect/ConstantPool;"
            instantiatedTypes = ["java/reflect/ConstantPool"]
          },
          {
            cf = "java/lang/Class", m = "getDeclaredConstructors0", desc = "(Z)[Ljava/reflect/Constructor;"
            instantiatedTypes = ["java/reflect/Constructor"]
          },
          {
            cf = "java/lang/Class", m = "getDeclaredFields0", desc = "(Z)[Ljava/reflect/Field;"
            instantiatedTypes = ["java/reflect/Field"]
          },
          {
            cf = "java/lang/Class", m = "getDeclaredMethods0", desc = "(Z)[Ljava/reflect/Method;"
            instantiatedTypes = ["java/reflect/Method"]
          },
          {
            cf = "java/lang/Class", m = "getPrimitiveClass", desc = "(Ljava/lang/String;)Ljava/lang/Class;"
            instantiatedTypes = ["java/lang/Class"]
          },
          {
            cf = "java/lang/Class", m = "getProtectionDomain0", desc = "()Ljava/security/ProtectionDomain;"
            instantiatedTypes = ["java/security/ProtectionDomain"]
          },
          {
            cf = "java/lang/ClassLoader", m = "defineClass0", desc = "(Ljava/lang/String;[BIILjava/securityProtectionDomain;)Ljava/lang/Class;"
            instantiatedTypes = ["java/lang/Class"]
          },
          {
            cf = "java/lang/ClassLoader", m = "defineClass1", desc = "(Ljava/lang/String;[BIILjava/securityProtectionDomain;Ljava/lang/String;)Ljava/lang/Class;"
            instantiatedTypes = ["java/lang/Class"]
          },
          {
            cf = "java/lang/ClassLoader", m = "defineClass2", desc = "(Ljava/lang/String;Ljava/nio/ByteBuffer;IILjava/securityProtectionDomain;Ljava/lang/String;)Ljava/lang/Class;"
            instantiatedTypes = ["java/lang/Class"]
          },
          {
            cf = "java/lang/ClassLoader", m = "findBootstrapClass", desc = "(Ljava/lang/String;)Ljava/lang/Class;"
            instantiatedTypes = ["java/lang/Class"]
          },
          {
            cf = "java/lang/ClassLoader", m = "findLoadedClass0", desc = "(Ljava/lang/String;)Ljava/lang/Class;"
            instantiatedTypes = ["java/lang/Class"]
          },
          {
            cf = "java/lang/ClassLoader", m = "retrieveDirectives", desc = "()Ljava/lang/AssertionStatusDirectives;"
            instantiatedTypes = ["java/lang/AssertionStatusDirectives"]
          },
          {
            cf = "java/lang/SecurityManager", m = "currentClassLoader0", desc = "()Ljava/lang/ClassLoader;"
            instantiatedTypes = ["java/lang/ClassLoader"]
          },
          {
            cf = "java/lang/SecurityManager", m = "currentLoadedClass0", desc = "()Ljava/lang/Class;"
            instantiatedTypes = ["java/lang/Class"]
          },
          {
            cf = "java/lang/System", m = "registerNatives", desc = "()V",
            reachableMethods = [
              {cf = "java/lang/System", m = "initializeSystemClass", desc = "()V"}
            ]
          },
          {
            cf = "java/lang/Thread", m = "currentThread", desc = "()Ljava/lang/Thread;"
            instantiatedTypes = ["java/lang/Thread"]
          },
          {
            cf = "java/lang/Thread", m = "dumpThreads", desc = "()[[Ljava/lang/StackTraceElement;"
            instantiatedTypes = ["java/lang/StackTraceElement"]
          },
          {
            cf = "java/lang/Thread", m = "getThreads", desc = "()[Ljava/lang/Thread;"
            instantiatedTypes = ["java/lang/Thread"]
          },
          {
            cf = "java/lang/Throwable", m = "getStackTraceElement", desc = "()Ljava/lang/StackTraceElement;"
            instantiatedTypes = ["java/lang/StackTraceElement"]
          },
          {
            cf = "java/lang/reflect/Executable", m = "getParameters0", desc = "()[Ljava/lang/reflect/Parameter;"
            instantiatedTypes = ["java/lang/reflect/Parameter"]
          },
          {
            cf = "java/lang/reflect/Proxy", m = "defineClass0", desc = "(Ljava/lang/ClassLoader;Ljava/lang/String;[BII)Ljava/lang/Class;"
            instantiatedTypes = ["java/lang/Class"]
          }
        ]
      }
    }
  }

}
