/* BSD 2-Clause License:
 * Copyright (c) 2009 - 2014
 * Software Technology Group
 * Department of Computer Science
 * Technische Universität Darmstadt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  - Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *  - Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
package org.opalj
package graphs

import org.opalj.collection.mutable.IntArrayStack

/**
 * The (post) dominator tree of a control flow graph. To construct a dominator tree use this
 * class' companion object. To compute a post dominator tree use
 * [[org.opalj.graphs.PostDominatorTree]].
 *
 * @param idom The array contains for each node its immediate dominator.
 * 			If not all unique ids are used then the array is a sparse array and external
 * 			knowledge is necessary to determine which elements of the array contain useful
 * 			information.
 *
 * @author Michael Eichberg
 */
class DominatorTree private (idom: Array[Int], startNode: Int) {

    /**
     * Returns the immediate dominator of the node with the given id.
     *
     * @note The root node does not have an immediate dominator!
     */
    final def dom(n: Int): Int = {
        if (n == startNode) {
            val errorMessage = "the root node does not have an immediate dominator"
            throw new IllegalArgumentException(errorMessage)
        }

        idom(n)
    }

    /**
     * Iterates over all dominator nodes of the given node. Iteration starts with the immediate
     * dominator of the given node if reflexive is `false` and starts with the node itself
     * if reflexive is `true`.
     * For postdominators, it includes an extra node outside the range of valid nodes.
     */
    final def foreachDom[U](n: Int, reflexive: Boolean = false)(f: Int ⇒ U): Unit = {
        if (n != startNode || reflexive) {
            var c = if (reflexive) n else idom(n)
            while (c != startNode) {
                f(c)
                c = idom(c)
            }
            f(startNode)
        }
    }

    def immediateDominators: IndexedSeq[Int] = idom

    /**
     * @param isIndexValid A function that returns true if an element in the iDom array with a
     * 		specific index is actually containing some valid data. This is particularly useful/
     * 		required if the `idom` array given at initialization time is a sparse array.
     */
    def toDot(isIndexValid: (Int) ⇒ Boolean = (i) ⇒ true): String = {
        val g = Graph.empty[Int]
        idom.zipWithIndex.foreach { e ⇒
            val (t, s /*index*/ ) = e
            if (isIndexValid(s) && s != startNode)
                g += (t, s)
        }
        g.toDot(rankdir = "BT", dir = "forward", ranksep = "0.3")
    }

    // THE FOLLOWING FUNCTION IS REALLY EXPENSIVE (DUE TO (UN)BOXING)
    // AND THEREFORE NO LONGER SUPPORTED
    // def toMap(nodes: Traversable[Int]): mutable.Map[Int, List[Int]] = {
    //     val dominators = mutable.Map(0 → List(0))
    //
    //     for (n ← nodes if !dominators.contains(n)) {
    //         // Since we traverse the dom tree no "visited" checks are necessary.
    //
    //         // The method needs to be tail recursive to be able to handle "larger graphs"
    //         // which are,e.g., generated by large methods.
    //         @tailrec def traverseDomTree(path: List[Int]): List[Int] = {
    //             val node = path.head
    //             dominators.get(node) match {
    //                case Some(nodeDoms) ⇒
    //                     // we have found a node for which we already have the list of dominators
    //                     var accDoms = nodeDoms
    //                     path.tail foreach { n ⇒
    //                         accDoms ::= n
    //                         // let's also update the map to speed up overall processing
    //                         dominators(n) = accDoms
    //                     }
    //                     accDoms
    //
    //                 case None ⇒
    //                     traverseDomTree(dom(node) :: path)
    //             }
    //         }
    //         dominators(n) = traverseDomTree(List(n))
    //     }
    //
    //     dominators
    // }

}

/**
 * Factory to compute [[DominatorTree]]s.
 *
 * @author Stephan Neumann
 * @author Michael Eichberg
 */
object DominatorTree {

    /**
     * Computes the immediate dominators for each node of a given graph where each node
     * is identified using a unique int value (e.g. the pc of an instruction) in the range
     * [0..maxNode], although not all ids need to be used.
     *
     * @param startNode The id of the unique root node of the graph. (E.g., (pc=)"0" for the CFG
     * 			computed for some method.
     * @param foreachSuccessorOf A function that given a node executes the given function for
     * 			each direct successor.
     * @param foreachPredecessorOf A function that given a node executes the given function for
     * 			each direct predecessor. The signature of a function that can directly passed
     * 			as a parameter is:
     * 			{{{
     *  		final def foreachPredecessorOf(pc: PC)(f: PC ⇒ Unit): Unit
     *  		}}}
     * @param maxNode The largest unique int id that identifies a node. (E.g., in case of
     * 			the analysis of some code it is equivalent to the length of the code.)
     *
     * @return The computed dominator tree.
     *
     * @note 	This is an implementation of the "fast dominators" algorithm
     * 			presented by T. Lengauaer and R. Tarjan in
     * 			A Fast Algorithm for Finding Dominators in a Flowgraph
     * 			ACM Transactions on Programming Languages and Systems (TOPLAS) 1.1 (1979): 121-141
     */
    def apply(
        startNode:            Int,
        foreachSuccessorOf:   Int ⇒ ((Int ⇒ Unit) ⇒ Unit),
        foreachPredecessorOf: Int ⇒ ((Int ⇒ Unit) ⇒ Unit),
        maxNode:              Int
    ): DominatorTree = {

        val max = maxNode + 1

        var n = 0;
        val dom = new Array[Int](max)

        val parent = new Array[Int](max)
        val ancestor = new Array[Int](max)
        val vertex = new Array[Int](max + 1)
        val label = new Array[Int](max)
        val semi = new Array[Int](max)
        val bucket = new Array[Set[Int]](max)

        // Step 1 (assign dfsnum)
        val nodes = new IntArrayStack(initialSize = java.lang.Math.max(2, (max / 4)))
        nodes.push(startNode)
        while (nodes.nonEmpty) {
            val v = nodes.pop
            // The following "if" is necessary, because the recursive dfs impl. in the paper uses 
            // eager decent which may lead to the initialization and a subsequent
            // filtering of already visited nodes by the "if(semi(w)==0)" test.
            if (semi(v) == 0) {
                n = n + 1
                semi(v) = n
                label(v) = v
                vertex(n) = v
                dom(v) = v

                foreachSuccessorOf(v) { w ⇒
                    if (semi(w) == 0) {
                        parent(w) = v
                        nodes.push(w)
                    }
                }
            }
        }

        // Steps 2 & 3
        def eval(v: Int): Int = {
            if (ancestor(v) == 0) {
                v
            } else {
                compress(v)
                label(v)
            }
        }

        def compress(v: Int): Unit = {
            var theAncestor = ancestor(v)
            if (ancestor(theAncestor) != 0) {
                compress(theAncestor)
                theAncestor = ancestor(v)
                val ancestorLabel = label(theAncestor)
                if (semi(ancestorLabel) < semi(label(v))) {
                    label(v) = ancestorLabel
                }
                ancestor(v) = ancestor(theAncestor)
            }
        }

        var i = n
        while (i >= 2) {
            val w = vertex(i)

            // Step 2
            foreachPredecessorOf(w) { (v: Int) ⇒
                val u = eval(v)
                val uSemi = semi(u)
                if (uSemi < semi(w)) {
                    semi(w) = uSemi
                }
            }

            val v = vertex(semi(w))
            val b = bucket(v)
            bucket(v) = if (b ne null) { b + w } else { Set(w) }

            ancestor(w) = parent(w)

            // Step 3
            val wParent = parent(w)
            val wParentBucket = bucket(wParent)
            if (wParentBucket != null) {
                for (v ← wParentBucket) {
                    val u = eval(v)
                    dom(v) = if (semi(u) < semi(v)) u else wParent;
                }
                bucket(wParent) = null
            }
            i = i - 1
        }

        // Step 4
        var j = 2;
        while (j <= n) {
            val w = vertex(j)
            val domW = dom(w)
            if (domW != vertex(semi(w))) {
                dom(w) = dom(domW)
            }
            j = j + 1
        }

        new DominatorTree(dom, startNode)
    }

}
