# 3-Address Code / Quadruples Code / Static Single Assigment Form
OPAL provides an easy mechanism to transform Java bytecode into a 3-address code which is also sometimes called "Quadruples Code". The standard representation provided by OPAL is always in SSA form and is created after performing a low-level, highly configurable data-flow analysis; based on the configured low-level analysis, the amount of additional information about the program's values may differ greatly. In the simplest case, only basic type information is provided. In more advanced cases, constant computations are perfomed, constants are propagated, must-alias information is provided, dead paths due to progamming errors are automatically pruned, and so on. In all cases the 3-address code (in the following called **TAC**) immediately provides complete def-use information and the control-flow graph is also reified.

## Using the 3-Address Code (TAC)

### Exploring the 3-Address Code using the command line tool TAC
A very simple way to explore the TAC generated by OPAL is to use the TAC tool which is part of the *Abstract Interpretation Framework*. To use it, start the sbt console, change to the *Abstract Interpretation Framework* and specify the method for which you want to have the TAC.

    current_folder$ sbt shell
    > project AbstracInterpretationFramework
    > run -source <source jar; e.g., ../bi/target/scala-2.11/resource_managed/test/ai.jar> -class <name of the class; e.g., ai.domain.DeadVariables> -method <name of the mehtod; e.g., initialValueIsAlwaysDead>

If the method is found, you will get the control-flow graph and the TAC generated using a lightweight abstract interpretation/advanced data-flow analysis.

### Using the 3-Address Code
A very straight forward way to get a method's TAC is to use the respective `ProjectInformationKey` as shown in the next example.

    import org.opalj.ai._; import org.opalj.br._ ; import org.opalj.br.analyses._; import org.opalj.br.instructions._; import org.opalj.tac._

Load a project; here we load a test project which is part of OPAL and also load the public API of the JDK the latter is primarily done to get the complete type hierarchy.

    implicit val p = Project(new java.io.File("OPAL/bi/target/scala-2.11/resource_managed/test/ai.jar"),org.opalj.bytecode.RTJar)

Tell the project that it should make the 3-address code of the method available, when required:

    val tac = p.get(SimpleTACAIKey)

To get the TAC of a specific method, which has to have a body, just look it up:

    val cf = p.classFile(ObjectType("ai/domain/IntegerValuesFrenzy")).get
    val m = cf.findMethod("someSwitch").head
    val taCode = tac(m)

 In some cases, it is desirable to exchange the underlying data-flow analysis that is used as a foundation for creating the TAC. This can easily be done by updating `SimpleTACAIKey`'s `domain factory`. The latter is used when computing the TAC and can be changed ***before*** the key (`SimpleTACAIKey`) is passed to the project (`<Project>.get(SimpleTACAIKey)`).
 E.g., to set the domain to the simplest/most basic supported domain, you can use:

    SimpleTACAIKey.domainFactory = (p :SomeProject, cf : ClassFile,m : Method) => new domain.l0.BaseDomainWithDefUse(p,cf,m)

 For example, creating the TAC using the simplest domain – and a production build of OPAL – takes roughly one third of the time of using the default domain. However, the default domain provides many more information and is therefore the recommended base analysis. To be more precise, on a Core i7 (4 Cores - Sandy Bridge, 2011) generating the standard TAC for the rt.jar of the JDK 8u121 using the simplest possible domain takes 13 seconds and for the default domain 33 seconds. 

## Examples

To better understand the TAC provided by OPAL, we will discuss some examples. You can run the examples on your own using the discussed steps.
