/**
 * generated by Xtext
 */
package org.opalj.bdl.ui.outline;

import com.google.common.base.Objects;
import com.google.inject.Inject;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.ui.editor.outline.IOutlineNode;
import org.eclipse.xtext.ui.editor.outline.impl.DefaultOutlineTreeProvider;
import org.eclipse.xtext.ui.editor.outline.impl.DocumentRootNode;
import org.eclipse.xtext.ui.editor.outline.impl.EStructuralFeatureNode;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Extension;
import org.opalj.bdl.bDL.BDLPackage;
import org.opalj.bdl.bDL.IssueCategories;
import org.opalj.bdl.bDL.IssueCategoryElement;
import org.opalj.bdl.bDL.IssueClassElement;
import org.opalj.bdl.bDL.IssueElement;
import org.opalj.bdl.bDL.IssueKindElement;
import org.opalj.bdl.bDL.IssuePackageElement;
import org.opalj.bdl.bDL.IssueRelevanceElement;
import org.opalj.bdl.services.BDLGrammarAccess;

/**
 * Customization of the default outline structure.
 * 
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#outline
 */
@SuppressWarnings("all")
public class BDLOutlineTreeProvider extends DefaultOutlineTreeProvider {
  public static String KEY_FILTERBY_TYPE = "filter by type";
  
  public static String KEY_FILTERBY_RELEVANCE = "filter by relevance";
  
  public static String KEY_FILTERBY_CATEGORY = "filter by category";
  
  public static String KEY_FILTERBY_KINDS = "filter by kind";
  
  public static String KEY_FILTERBY_PACKAGES = "filter by package";
  
  public static String KEY_FILTERBY_CLASS = "filter by class";
  
  public static String[] KEYS_FILTERBY = { BDLOutlineTreeProvider.KEY_FILTERBY_TYPE, BDLOutlineTreeProvider.KEY_FILTERBY_RELEVANCE, BDLOutlineTreeProvider.KEY_FILTERBY_CATEGORY, BDLOutlineTreeProvider.KEY_FILTERBY_KINDS, BDLOutlineTreeProvider.KEY_FILTERBY_PACKAGES, BDLOutlineTreeProvider.KEY_FILTERBY_CLASS };
  
  @Inject
  @Extension
  BDLGrammarAccess _bDLGrammarAccess;
  
  @Override
  protected void _createChildren(final DocumentRootNode parentNode, final EObject modelElement) {
    this.createNode(parentNode, modelElement);
    HashSet<String> _hashSet = new HashSet<String>((Collection<? extends String>)Conversions.doWrapArray(BDLOutlineTreeProvider.KEYS_FILTERBY));
    this.showPossibleFilters(parentNode, modelElement, _hashSet);
  }
  
  @Override
  public void createChildren(final IOutlineNode parent, final EObject modelElement) {
    if ((!(parent instanceof EStructuralFeatureNode))) {
      super.createChildren(parent, modelElement);
      return;
    }
    HashMap<String, String> appliedFilters = this.getAppliedFilters(parent);
    HashSet<IssueElement> filteredIssues = this.getFilteredIssues(modelElement, appliedFilters);
    Object _text = parent.getText();
    boolean _contains = ((List<String>)Conversions.doWrapArray(BDLOutlineTreeProvider.KEYS_FILTERBY)).contains(_text);
    if (_contains) {
      Object _text_1 = parent.getText();
      this.showPossibleOptionsForFilter(parent, modelElement, ((String) _text_1), filteredIssues);
    } else {
      HashSet<String> possible = this.getPossibleFilters(appliedFilters);
      this.showPossibleFilters(parent, modelElement, possible);
      for (final IssueElement issue : filteredIssues) {
        this.createNode(parent, issue);
      }
    }
  }
  
  public HashSet<String> getPossibleFilters(final HashMap<String, String> used) {
    HashSet<String> possible = new HashSet<String>((Collection<? extends String>)Conversions.doWrapArray(BDLOutlineTreeProvider.KEYS_FILTERBY));
    Set<String> _keySet = used.keySet();
    for (final String sKey : _keySet) {
      possible.remove(sKey);
    }
    return possible;
  }
  
  public HashMap<String, String> getAppliedFilters(final IOutlineNode parent) {
    HashMap<String, String> ret = new HashMap<String, String>();
    IOutlineNode previous = null;
    IOutlineNode current = parent;
    while ((!Objects.equal(current, null))) {
      {
        boolean _and = false;
        if (!(current instanceof EStructuralFeatureNode)) {
          _and = false;
        } else {
          boolean _notEquals = (!Objects.equal(previous, null));
          _and = _notEquals;
        }
        if (_and) {
          Object _text = current.getText();
          boolean _contains = ((List<String>)Conversions.doWrapArray(BDLOutlineTreeProvider.KEYS_FILTERBY)).contains(_text);
          if (_contains) {
            Object _text_1 = current.getText();
            Object _text_2 = previous.getText();
            ret.put(((String) _text_1), ((String) _text_2));
          }
        }
        previous = current;
        IOutlineNode _parent = current.getParent();
        current = _parent;
      }
    }
    return ret;
  }
  
  public void showPossibleFilters(final IOutlineNode parent, final EObject modelElement, final HashSet<String> possible) {
    for (final String sFilter : possible) {
      this.createEStructuralFeatureNode(parent, modelElement, BDLPackage.Literals.MODEL_CONTAINER__NAME, null, sFilter, false);
    }
  }
  
  public void showPossibleOptionsForFilter(final IOutlineNode parent, final EObject modelElement, final String filter, final HashSet<IssueElement> currentIssues) {
    HashSet<Object> created = new HashSet<Object>();
    for (final IssueElement issue : currentIssues) {
      boolean _equals = filter.equals(BDLOutlineTreeProvider.KEY_FILTERBY_TYPE);
      if (_equals) {
        for (int i = 0; (i < ((Object[])Conversions.unwrapArray(issue.getName(), Object.class)).length); i++) {
          EList<String> _name = issue.getName();
          String _get = _name.get(i);
          boolean _contains = created.contains(_get);
          boolean _not = (!_contains);
          if (_not) {
            EList<String> _name_1 = issue.getName();
            String _get_1 = _name_1.get(i);
            created.add(_get_1);
            EList<String> _name_2 = issue.getName();
            String _get_2 = _name_2.get(i);
            this.createEStructuralFeatureNode(parent, modelElement, BDLPackage.Literals.MODEL_CONTAINER__NAME, null, _get_2, false);
          }
        }
      } else {
        boolean _equals_1 = filter.equals(BDLOutlineTreeProvider.KEY_FILTERBY_RELEVANCE);
        if (_equals_1) {
          IssueRelevanceElement _relevance = issue.getRelevance();
          int _relevance_1 = _relevance.getRelevance();
          boolean _contains = created.contains(Integer.valueOf(_relevance_1));
          boolean _not = (!_contains);
          if (_not) {
            IssueRelevanceElement _relevance_2 = issue.getRelevance();
            int _relevance_3 = _relevance_2.getRelevance();
            created.add(Integer.valueOf(_relevance_3));
            IssueRelevanceElement _relevance_4 = issue.getRelevance();
            int _relevance_5 = _relevance_4.getRelevance();
            String _string = Integer.valueOf(_relevance_5).toString();
            this.createEStructuralFeatureNode(parent, modelElement, BDLPackage.Literals.MODEL_CONTAINER__NAME, null, _string, false);
          }
        } else {
          boolean _equals_2 = filter.equals(BDLOutlineTreeProvider.KEY_FILTERBY_CATEGORY);
          if (_equals_2) {
            IssueCategoryElement _categories = issue.getCategories();
            EList<IssueCategories> _elements = _categories.getElements();
            for (final IssueCategories cat : _elements) {
              {
                String sCat = this.getIssueCategoryKey(cat);
                boolean _contains_1 = created.contains(sCat);
                boolean _not_1 = (!_contains_1);
                if (_not_1) {
                  created.add(sCat);
                  this.createEStructuralFeatureNode(parent, modelElement, BDLPackage.Literals.MODEL_CONTAINER__NAME, null, sCat, false);
                }
              }
            }
          } else {
            boolean _equals_3 = filter.equals(BDLOutlineTreeProvider.KEY_FILTERBY_KINDS);
            if (_equals_3) {
              IssueKindElement _kinds = issue.getKinds();
              EList<String> _elements_1 = _kinds.getElements();
              for (final String kind : _elements_1) {
                boolean _contains_1 = created.contains(kind);
                boolean _not_1 = (!_contains_1);
                if (_not_1) {
                  created.add(kind);
                  this.createEStructuralFeatureNode(parent, modelElement, BDLPackage.Literals.MODEL_CONTAINER__NAME, null, kind, false);
                }
              }
            } else {
              boolean _equals_4 = filter.equals(BDLOutlineTreeProvider.KEY_FILTERBY_PACKAGES);
              if (_equals_4) {
                IssuePackageElement _package = issue.getPackage();
                String _package_1 = _package.getPackage();
                boolean _contains_2 = created.contains(_package_1);
                boolean _not_2 = (!_contains_2);
                if (_not_2) {
                  IssuePackageElement _package_2 = issue.getPackage();
                  String _package_3 = _package_2.getPackage();
                  created.add(_package_3);
                  IssuePackageElement _package_4 = issue.getPackage();
                  String _package_5 = _package_4.getPackage();
                  String _string_1 = _package_5.toString();
                  this.createEStructuralFeatureNode(parent, modelElement, BDLPackage.Literals.MODEL_CONTAINER__NAME, null, _string_1, false);
                }
              } else {
                boolean _equals_5 = filter.equals(BDLOutlineTreeProvider.KEY_FILTERBY_CLASS);
                if (_equals_5) {
                  IssueClassElement _class_ = issue.getClass_();
                  String _class__1 = _class_.getClass_();
                  boolean _contains_3 = created.contains(_class__1);
                  boolean _not_3 = (!_contains_3);
                  if (_not_3) {
                    IssueClassElement _class__2 = issue.getClass_();
                    String _class__3 = _class__2.getClass_();
                    created.add(_class__3);
                    IssueClassElement _class__4 = issue.getClass_();
                    String _class__5 = _class__4.getClass_();
                    String _string_2 = _class__5.toString();
                    this.createEStructuralFeatureNode(parent, modelElement, BDLPackage.Literals.MODEL_CONTAINER__NAME, null, _string_2, false);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  public HashSet<IssueElement> getFilteredIssues(final EObject modelElement, final HashMap<String, String> appliedFilters) {
    HashSet<IssueElement> ret = new HashSet<IssueElement>();
    TreeIterator<EObject> iter = modelElement.eAllContents();
    while (iter.hasNext()) {
      {
        EObject current = iter.next();
        EClass _eClass = current.eClass();
        String _name = _eClass.getName();
        boolean _equals = _name.equals("IssueElement");
        if (_equals) {
          IssueElement issue = ((IssueElement) current);
          boolean isOK = true;
          Set<String> _keySet = appliedFilters.keySet();
          for (final String filter : _keySet) {
            {
              boolean thisFilter = false;
              boolean _equals_1 = filter.equals(BDLOutlineTreeProvider.KEY_FILTERBY_TYPE);
              if (_equals_1) {
                for (int i = 0; (i < ((Object[])Conversions.unwrapArray(issue.getName(), Object.class)).length); i++) {
                  EList<String> _name_1 = issue.getName();
                  String _get = _name_1.get(i);
                  String _get_1 = appliedFilters.get(filter);
                  boolean _equals_2 = _get.equals(_get_1);
                  if (_equals_2) {
                    thisFilter = true;
                  }
                }
              } else {
                boolean _equals_2 = filter.equals(BDLOutlineTreeProvider.KEY_FILTERBY_RELEVANCE);
                if (_equals_2) {
                  IssueRelevanceElement _relevance = issue.getRelevance();
                  int _relevance_1 = _relevance.getRelevance();
                  String _string = Integer.valueOf(_relevance_1).toString();
                  String _get = appliedFilters.get(filter);
                  boolean _equals_3 = _string.equals(_get);
                  if (_equals_3) {
                    thisFilter = true;
                  }
                } else {
                  boolean _equals_4 = filter.equals(BDLOutlineTreeProvider.KEY_FILTERBY_CATEGORY);
                  if (_equals_4) {
                    for (int i = 0; (i < ((Object[])Conversions.unwrapArray(issue.getCategories().getElements(), Object.class)).length); i++) {
                      {
                        IssueCategoryElement _categories = issue.getCategories();
                        EList<IssueCategories> _elements = _categories.getElements();
                        IssueCategories _get_1 = _elements.get(i);
                        String catK = this.getIssueCategoryKey(_get_1);
                        String _get_2 = appliedFilters.get(filter);
                        boolean _equals_5 = catK.equals(_get_2);
                        if (_equals_5) {
                          thisFilter = true;
                        }
                      }
                    }
                  } else {
                    boolean _equals_5 = filter.equals(BDLOutlineTreeProvider.KEY_FILTERBY_KINDS);
                    if (_equals_5) {
                      for (int i = 0; (i < ((Object[])Conversions.unwrapArray(issue.getKinds().getElements(), Object.class)).length); i++) {
                        IssueKindElement _kinds = issue.getKinds();
                        EList<String> _elements = _kinds.getElements();
                        String _get_1 = _elements.get(i);
                        String _get_2 = appliedFilters.get(filter);
                        boolean _equals_6 = _get_1.equals(_get_2);
                        if (_equals_6) {
                          thisFilter = true;
                        }
                      }
                    } else {
                      boolean _equals_6 = filter.equals(BDLOutlineTreeProvider.KEY_FILTERBY_PACKAGES);
                      if (_equals_6) {
                        IssuePackageElement _package = issue.getPackage();
                        String _package_1 = _package.getPackage();
                        String _string_1 = _package_1.toString();
                        String _get_1 = appliedFilters.get(filter);
                        boolean _equals_7 = _string_1.equals(_get_1);
                        if (_equals_7) {
                          thisFilter = true;
                        }
                      } else {
                        boolean _equals_8 = filter.equals(BDLOutlineTreeProvider.KEY_FILTERBY_CLASS);
                        if (_equals_8) {
                          IssueClassElement _class_ = issue.getClass_();
                          String _class__1 = _class_.getClass_();
                          String _string_2 = _class__1.toString();
                          String _get_2 = appliedFilters.get(filter);
                          boolean _equals_9 = _string_2.equals(_get_2);
                          if (_equals_9) {
                            thisFilter = true;
                          }
                        }
                      }
                    }
                  }
                }
              }
              isOK = (isOK && thisFilter);
            }
          }
          if (isOK) {
            ret.add(issue);
          }
        }
      }
    }
    return ret;
  }
  
  @Override
  protected boolean _isLeaf(final EObject modelElement) {
    boolean _xblockexpression = false;
    {
      if ((modelElement instanceof IssueCategoryElement)) {
        return true;
      }
      _xblockexpression = super._isLeaf(modelElement);
    }
    return _xblockexpression;
  }
  
  public static String KEY_CATEGORY_BUG = "bug";
  
  public static String KEY_CATEGORY_COMPREHENSIBILITY = "comprehensibility";
  
  public static String KEY_CATEGORY_SMELL = "smell";
  
  public static String KEY_CATEGORY_PERFORMANCE = "performance";
  
  public String getIssueCategoryKey(final IssueCategories cat) {
    boolean _and = false;
    String _bug = cat.getBug();
    boolean _notEquals = (!Objects.equal(_bug, null));
    if (!_notEquals) {
      _and = false;
    } else {
      String _bug_1 = cat.getBug();
      int _length = _bug_1.length();
      boolean _greaterThan = (_length > 0);
      _and = _greaterThan;
    }
    if (_and) {
      return BDLOutlineTreeProvider.KEY_CATEGORY_BUG;
    }
    boolean _and_1 = false;
    String _smell = cat.getSmell();
    boolean _notEquals_1 = (!Objects.equal(_smell, null));
    if (!_notEquals_1) {
      _and_1 = false;
    } else {
      String _smell_1 = cat.getSmell();
      int _length_1 = _smell_1.length();
      boolean _greaterThan_1 = (_length_1 > 0);
      _and_1 = _greaterThan_1;
    }
    if (_and_1) {
      return BDLOutlineTreeProvider.KEY_CATEGORY_SMELL;
    }
    boolean _and_2 = false;
    String _comprehensibility = cat.getComprehensibility();
    boolean _notEquals_2 = (!Objects.equal(_comprehensibility, null));
    if (!_notEquals_2) {
      _and_2 = false;
    } else {
      String _comprehensibility_1 = cat.getComprehensibility();
      int _length_2 = _comprehensibility_1.length();
      boolean _greaterThan_2 = (_length_2 > 0);
      _and_2 = _greaterThan_2;
    }
    if (_and_2) {
      return BDLOutlineTreeProvider.KEY_CATEGORY_COMPREHENSIBILITY;
    }
    boolean _and_3 = false;
    String _performance = cat.getPerformance();
    boolean _notEquals_3 = (!Objects.equal(_performance, null));
    if (!_notEquals_3) {
      _and_3 = false;
    } else {
      String _performance_1 = cat.getPerformance();
      int _length_3 = _performance_1.length();
      boolean _greaterThan_3 = (_length_3 > 0);
      _and_3 = _greaterThan_3;
    }
    if (_and_3) {
      return BDLOutlineTreeProvider.KEY_CATEGORY_PERFORMANCE;
    }
    return null;
  }
}
