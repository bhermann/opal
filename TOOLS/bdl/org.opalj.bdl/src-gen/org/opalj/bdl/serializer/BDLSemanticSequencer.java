/*
 * generated by Xtext
 */
package org.opalj.bdl.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.opalj.bdl.bDL.BDLPackage;
import org.opalj.bdl.bDL.IssueCategories;
import org.opalj.bdl.bDL.IssueCategoryElement;
import org.opalj.bdl.bDL.IssueClassElement;
import org.opalj.bdl.bDL.IssueElement;
import org.opalj.bdl.bDL.IssueKindElement;
import org.opalj.bdl.bDL.IssuePackageElement;
import org.opalj.bdl.bDL.IssueRelevanceElement;
import org.opalj.bdl.bDL.IssueSuppressComment;
import org.opalj.bdl.bDL.IssuesTitleElement;
import org.opalj.bdl.bDL.ModelContainer;
import org.opalj.bdl.bDL.ParameterContainer;
import org.opalj.bdl.bDL.ParameterKeyElement;
import org.opalj.bdl.bDL.ParameterKeyValueElement;
import org.opalj.bdl.services.BDLGrammarAccess;

@SuppressWarnings("all")
public class BDLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private BDLGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == BDLPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case BDLPackage.ISSUE_CATEGORIES:
				sequence_IssueCategories(context, (IssueCategories) semanticObject); 
				return; 
			case BDLPackage.ISSUE_CATEGORY_ELEMENT:
				sequence_IssueCategoryElement(context, (IssueCategoryElement) semanticObject); 
				return; 
			case BDLPackage.ISSUE_CLASS_ELEMENT:
				sequence_IssueClassElement(context, (IssueClassElement) semanticObject); 
				return; 
			case BDLPackage.ISSUE_ELEMENT:
				sequence_IssueElement(context, (IssueElement) semanticObject); 
				return; 
			case BDLPackage.ISSUE_KIND_ELEMENT:
				sequence_IssueKindElement(context, (IssueKindElement) semanticObject); 
				return; 
			case BDLPackage.ISSUE_PACKAGE_ELEMENT:
				sequence_IssuePackageElement(context, (IssuePackageElement) semanticObject); 
				return; 
			case BDLPackage.ISSUE_RELEVANCE_ELEMENT:
				sequence_IssueRelevanceElement(context, (IssueRelevanceElement) semanticObject); 
				return; 
			case BDLPackage.ISSUE_SUPPRESS_COMMENT:
				sequence_IssueSuppressComment(context, (IssueSuppressComment) semanticObject); 
				return; 
			case BDLPackage.ISSUES_TITLE_ELEMENT:
				if(context == grammarAccess.getIssuesContainerRule()) {
					sequence_IssuesContainer_IssuesTitleElement(context, (IssuesTitleElement) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getIssuesTitleElementRule()) {
					sequence_IssuesTitleElement(context, (IssuesTitleElement) semanticObject); 
					return; 
				}
				else break;
			case BDLPackage.MODEL_CONTAINER:
				sequence_ModelContainer(context, (ModelContainer) semanticObject); 
				return; 
			case BDLPackage.PARAMETER_CONTAINER:
				sequence_ParameterContainer(context, (ParameterContainer) semanticObject); 
				return; 
			case BDLPackage.PARAMETER_KEY_ELEMENT:
				sequence_ParameterKeyElement(context, (ParameterKeyElement) semanticObject); 
				return; 
			case BDLPackage.PARAMETER_KEY_VALUE_ELEMENT:
				sequence_ParameterKeyValueElement(context, (ParameterKeyValueElement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (bug='bug' | smell='smell' | performance='performance' | comprehensibility='comprehensibility')
	 */
	protected void sequence_IssueCategories(EObject context, IssueCategories semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name='Categories:' elements+=IssueCategories elements+=IssueCategories*)
	 */
	protected void sequence_IssueCategoryElement(EObject context, IssueCategoryElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name='Class:' class=IssueClass)
	 */
	protected void sequence_IssueClassElement(EObject context, IssueClassElement semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BDLPackage.Literals.ISSUE_CLASS_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BDLPackage.Literals.ISSUE_CLASS_ELEMENT__NAME));
			if(transientValues.isValueTransient(semanticObject, BDLPackage.Literals.ISSUE_CLASS_ELEMENT__CLASS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BDLPackage.Literals.ISSUE_CLASS_ELEMENT__CLASS));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getIssueClassElementAccess().getNameClassKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getIssueClassElementAccess().getClassIssueClassParserRuleCall_1_0(), semanticObject.getClass_());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name+=IssueTypes 
	 *         name+=IssueTypes* 
	 *         comment=IssueSuppressComment? 
	 *         message=STRING? 
	 *         categories=IssueCategoryElement 
	 *         kinds=IssueKindElement 
	 *         relevance=IssueRelevanceElement 
	 *         package=IssuePackageElement 
	 *         class=IssueClassElement
	 *     )
	 */
	protected void sequence_IssueElement(EObject context, IssueElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name='Kinds:' elements+=IssueKinds elements+=IssueKinds*)
	 */
	protected void sequence_IssueKindElement(EObject context, IssueKindElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name='Package:' package=SlashPath)
	 */
	protected void sequence_IssuePackageElement(EObject context, IssuePackageElement semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BDLPackage.Literals.ISSUE_PACKAGE_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BDLPackage.Literals.ISSUE_PACKAGE_ELEMENT__NAME));
			if(transientValues.isValueTransient(semanticObject, BDLPackage.Literals.ISSUE_PACKAGE_ELEMENT__PACKAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BDLPackage.Literals.ISSUE_PACKAGE_ELEMENT__PACKAGE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getIssuePackageElementAccess().getNamePackageKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getIssuePackageElementAccess().getPackageSlashPathParserRuleCall_1_0(), semanticObject.getPackage());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name='Relevance:' relevance=INT)
	 */
	protected void sequence_IssueRelevanceElement(EObject context, IssueRelevanceElement semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BDLPackage.Literals.ISSUE_RELEVANCE_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BDLPackage.Literals.ISSUE_RELEVANCE_ELEMENT__NAME));
			if(transientValues.isValueTransient(semanticObject, BDLPackage.Literals.ISSUE_RELEVANCE_ELEMENT__RELEVANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BDLPackage.Literals.ISSUE_RELEVANCE_ELEMENT__RELEVANCE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getIssueRelevanceElementAccess().getNameRelevanceKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getIssueRelevanceElementAccess().getRelevanceINTTerminalRuleCall_1_0(), semanticObject.getRelevance());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (value=ID | value=STRING)
	 */
	protected void sequence_IssueSuppressComment(EObject context, IssueSuppressComment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name='Issues' elements+=IssueElement*)
	 */
	protected void sequence_IssuesContainer_IssuesTitleElement(EObject context, IssuesTitleElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name='Issues'
	 */
	protected void sequence_IssuesTitleElement(EObject context, IssuesTitleElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=AnalysisElement parameter=ParameterContainer issues=IssuesContainer)
	 */
	protected void sequence_ModelContainer(EObject context, ModelContainer semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BDLPackage.Literals.MODEL_CONTAINER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BDLPackage.Literals.MODEL_CONTAINER__NAME));
			if(transientValues.isValueTransient(semanticObject, BDLPackage.Literals.MODEL_CONTAINER__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BDLPackage.Literals.MODEL_CONTAINER__PARAMETER));
			if(transientValues.isValueTransient(semanticObject, BDLPackage.Literals.MODEL_CONTAINER__ISSUES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BDLPackage.Literals.MODEL_CONTAINER__ISSUES));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getModelContainerAccess().getNameAnalysisElementParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getModelContainerAccess().getParameterParameterContainerParserRuleCall_1_0(), semanticObject.getParameter());
		feeder.accept(grammarAccess.getModelContainerAccess().getIssuesIssuesContainerParserRuleCall_2_0(), semanticObject.getIssues());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ParametersElement elements+=ParameterElement+)
	 */
	protected void sequence_ParameterContainer(EObject context, ParameterContainer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ParameterKeyElement(EObject context, ParameterKeyElement semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BDLPackage.Literals.PARAMETER_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BDLPackage.Literals.PARAMETER_ELEMENT__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getParameterKeyElementAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID value=AnyValues)
	 */
	protected void sequence_ParameterKeyValueElement(EObject context, ParameterKeyValueElement semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BDLPackage.Literals.PARAMETER_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BDLPackage.Literals.PARAMETER_ELEMENT__NAME));
			if(transientValues.isValueTransient(semanticObject, BDLPackage.Literals.PARAMETER_KEY_VALUE_ELEMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BDLPackage.Literals.PARAMETER_KEY_VALUE_ELEMENT__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getParameterKeyValueElementAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getParameterKeyValueElementAccess().getValueAnyValuesParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
}
